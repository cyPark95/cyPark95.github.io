---
layout: post
title: "[Real MySQL 8.0] 4장 내용 정리"
summary: "Real MySQL 8.0 - 그룹 스터디 2주차"
author: pcy
date: '2023-09-21 21:30:00 +0530'
category: [ 'Group', 'Study', 'MySQL', 'Book' ]
thumbnail: /assets/img/posts/group/realmysql/RealMySQL(1).png
comments: true
---
> 💡
> ❗
# 4장: 아키텍처

- MySQL 서버는 MySQL 엔진과 스토리지 엔진로 구분할 수 있다.
    - MySQL 엔지: 사람의 머리 역할
    - 스토리지 엔진: 손발 역할

## MySQL 엔진 아키텍처

- MySQL 서버는 다른 DBMS에 비해 독특한 구조를 갖는다.
    - 이러한 구조 때문에 혜택을 누릴 수도 있지만, 문제가 되기도 한다.

### MySQL의 전체 구조

<img alt="MySQL 전체 구조" src="/assets/img/posts/group/realmysql/2023-09-21-(1).png" style="width: 100%">

- MySQL은 드라이버를 통해 대부분의 프로그램 언어로부터 접근 방법을 모두 지원한다.
- MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

#### MySQL 엔진

- SQL 문장을 **분석**하거나 **최적화** 등 두뇌에 해당하는 처리를 수행한다.
- 구성
    - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러
    - SQL 파서 및 전처리기
    - 쿼리의 최적화된 실행을 위한 옵티마이저

#### 스토리지 엔진

- 실제 데이터를 디스크 스토리지로부터 **읽고 쓰는** 역할을 수행한다.
- 스토리지 엔진은 여러 개를 동시에 사용할 수 있다.
- 성능 향상을 위해 키 캐시(MyISAM 스토리지 엔진)나 InnoDB 버퍼 풀(InnoDB 스토리지 엔진)과 같은 기능을 내장하고 있다.

#### 핸들러 API

- MySQL 엔진의 쿼리 실행기에서 데이터를 쓰거나 읽을 때, 스토리지 엔진에 하는 요청을 **핸들러(Handler) 요청**이라 한다.
- 여기서 사용되는 API를 **핸들러 API**라고 한다.

### MySQL 스레딩 구조

<img alt="MySQL의 스레딩 모델" src="/assets/img/posts/group/realmysql/2023-09-21-(2).png" style="width: 100%">

- MySQL 서버는 프로세스가 아닌 스레드 기반으로 작동한다.
- 포그라운드(Foreground) 스레드와 백그라운드(Background) 스레드로 구분된다.

> 💡 스레드 풀과 전통적인 스레드 모델은 포그라운드 스레드와 커넥션의 관계에서 차이점이 있다.
>
> - 스레드 풀: 하나의 포그라운드 스레드가 여러 개의 커넥션 요청을 담당한다.
> - 전통적인 스레드 모델: 커넥션 별로 포그라운드 스레드가 하나씩 생성되고 할당된다.

#### 포그라운드 스레드(클라이언트 스레드)

- 주로 클라이언트에서 요청하는 쿼리 문장을 처리한다.
- 커넥션이 종료되면 해당 스레드는 최대 쓰레드 수(`thread_cache_size` 시스템 변수 값)에 따라 다시 스레드 캐시(Thread Cache)로 돌아가거나 종료된다.
- 스토리지 엔지에 따른 역할
    - MyISAM 스토리지 엔진: 포그라운드 스레드가 디스크 쓰기 작업까지 처리한다.
    - InnoDB 스토리지 엔진:  데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지는 백그라운드 스레드가 처리한다.

#### 백그라운드 스레드

- InnoDB 에서 백그라운드로 처리되는 작업
    - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
    - **로그를 디스크로 기록하는 스레드**
    - **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**
    - 데이터를 버퍼로 읽어 오는 스레드
    - 잠금이나 데드락을 모니터링 하는 스레드
- 데이터 쓰기 스레드(Write thread)와 읽기 스레드의 개수를 `innodb_wirte_io_threads`와 `innodb_read_io_threads` 시스템 변수를 통해 2개 이상 지정할 수 있다.
- 읽기 스레드는 클라이언트 스레드에서 처리되기 때문에 많이 설정할 필요가 없다.
- 쓰기 스레드는 많은 작업을 백그라운드로 처리하기 때문에 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는 것이 좋다.
    - InnoDB: 대부분의 쓰기 작업을 지연(버퍼링)을 통해 일괄 처리한다.
    - MyISAM: 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 메모리 할당 및 사용 구조

- MySQL에서 메모리 공간은 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분할 수 있다.

<img alt="MySQL의 메모리 사용 및 할당 구조" src="/assets/img/posts/group/realmysql/2023-09-21-(3).png" style="width: 100%">

#### 글로벌 메모리 영역

- MySQL 서버가 시작될 때, 시스템 변수로 설정해 둔 만큼 운영체제로부터 하나의 메모리 공간을 할당받는다.
- 모든 쓰레드에 의해 공유된다.
- 대표적인 글로벌 메모리 영역
    - 테이블 캐시
    - InnoDB 버퍼 풀
    - InnoDB 어댑티브 해시 인덱스
    - InnoDB 리두 로그 버퍼

#### 로컬 메모리 영역

- 세션 메모리 영역으로, 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.
- 스레드별로 독립적으로 할당되며, 공유되지 않는다.
- 대표적인 로컬 메모리 영역
    - 정렬 버퍼(Sort buffer)
    - 조인 버퍼
    - 바이너리 로그 캐시
    - 네트워크 버퍼

### 플러그인 스토리지 엔진 모델

- MySQL의 대표적인 독특한 구조
- 스토리지 엔진 뿐만 아니라 검색어 파서, 사용자 인증을 위한 알고리즘 등도 모두 플러그인으로 구현되어 제공된다.

<img alt="MySQL 엔진과 스토리지 엔진의 처리 영역" src="/assets/img/posts/group/realmysql/2023-09-21-(4).png" style="width: 100%">

- 퀴리가 실행되는 대부분의 작업이 MySQL 엔진에서 처리되고, 마지막 **데이터 읽기/쓰기 작업**만 스토리지 엔진에 의해 처리된다.
- MySQL 엔진은 `핸들러(Handler)`를 통해 스토리지 엔진을 조정한다.
- `SHOW ENGINES` MySQL 서버에서 지원되는 스토리지 엔진 확인 명령
- `SHOW PLUGIN` 설치된 플러그인 확인 명령
- [MySQL 플러그인 메뉴얼](https://dev.mysql.com/doc/refman/8.0/en/server-plugins.html)
- 플러그인 단점
    - 플러그인은 MySQL 서버와 인터페이스 할 수 있고, 플러그인끼리는 통신할 수 없다.
    - 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않다.
        - 캡슐화 되지 않는다.
    - 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화가 어렵다.

### 컴포넌트

- MySQL 8.0부터 플러그인 아키텍처의 단점을 보완하기 위해 컴포넌트 아키텍처가 지원된다.
- [MySQL 컴포넌트 메뉴얼](https://dev.mysql.com/doc/refman/8.0/en/components.html)

### 쿼리 실행 구조

<img alt="쿼리 실행 구조" src="/assets/img/posts/group/realmysql/2023-09-21-(5).png" style="width: 100%">

#### 쿼리 파서

- 쿼리 문장을 MySQL이 인실할 수 있는 최소 단위인 토큰으로 분리해 트리 형태의 구조로 만든다.
- 쿼리의 기본 문법 오류는 이 과정에서 발견되고, 사용자에게 메시지를 전달한다.

#### 전처리기

- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 검토한다.
- 테이블, 컬럼 등 존재 여부와 접근 권한 등을 확인한다.

#### 옵티마이저

- 쿼리 문장을 최소 비용으로 가장 빠르게 처리할지를 결정하는 역할을 한다.
    - 성능 최적화
- 트리를 토대로 필요하지 않은 조건은 제거하거나 연산 과정은 단순화한다.
    - 인덱스 사용 여부, 어떤 인덱스를 사용할지, 인덱스와 임시 테이블 중 어떤 걸 사용할지 등 계획 수립

#### 실행 엔진

- 옵티마이저로부터 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 한다.
    - 데이터를 조회하고, 결과를 정렬하거나 조인하고, 불필요한 데이터는 필터링 한다.

#### 핸들러(스토리지 엔진)

- MySQL 실행 엔진의 요청에 따라 디스크로부터 데이터를 읽고, 쓰는 역할을 한다.

### 쿼리 캐시

- 쿼리 캐시(Query Cache)는 SQL 실행 결과를 메모리에 캐시하고, 동일 쿼리가 실행되면 캐시에서 결과를 반환하기 때문에 빠른 성능을 보여줬다.
- 하지만 캐시에 저장된 데이터가 변경되면 관련된 것들을 삭제(Invalidate) 해야하기 때문에 동시 처리 성능 저하를 유발로 인해 MySQL 8.0부터 기능에서 완전히 제거됐다.

### 스레드 풀

- 스레드 풀(Thread Pool) 기능은 MySQL 서버 엔터프라이즈 에디션에서 제공하는 기능으로, 커뮤니티 에디션에서는 Percona Server에서 플러그인 형태로 제공하는 스레드 풀 기능을 사용할 수 있다.
- 스레드 풀은 `thread_pool_max_threads` 시스템 변수에 설정된 값 만큼 미리 초기화 해두고 요청이 들어오면 할당하는 방식이다.
    - CPU가 제한된 개수의 스레드 처리에 집중할 수 있게 하여 서버의 자원 소모를 줄일 수 있다.
    - 미리 생성된 스레드를 재사용함으로써 오버헤드를 줄일 수 있다.
    - 불필요한 컨텍스트 스위치(Context switch)를 줄여 오버헤드를 낮출 수 있다.
- 하지만 스케줄링 과정에서 CPU 시간을 확보하지 못하는 경우 쿼리 처리가 더 느려질 수 있다.
- 스레드 그룹 내의 모든 스레드가 작업 중일 때 새로운 요청이 들어오면, `thread_pool_stall_limit` 시스템 변수 시간 동안 대기하다가 새로운 스레드를 추가하여 요청을 처리할 수 있다.
- 선순위 큐와 후순위 큐를 통해 먼저 시작된 트랜잭션 내에 속한 SQL을 빨리 처리하여 **경합을 낮추고**, 전체적인 **성능을 향상**시킬 수 있다.

### 트랜잭션 지원 메타데이터

- 테이블 구조, 스토어드 프로그램 등의 정보를 **메타데이터**라고 한다.
- MySQL 8.0 버전부터는 메타데이터를 트랜잭션 기반의 InnoDB 테이블에 저장하여, 데이터의 일관성을 유지할 수 있도록 개선됐다.
- 메타데이터 정보는 `mysql` DB에 저장되고, DB 정보는 `mysql.ibd` 테이블 스페이스에 저장된다.

> 💡 사용자로부터 임의의 수정을 막기 위해 `mysql` DB에서는 테이블을 조회할 수 없고,
> `information_schema` DB의 뷰를 통해 조회할 수 있다.

> 💡 InnoDB 스토리지 엔진 이외의 스토리지 엔진을 사용하는 테이블들의 메타정보는 SDI(Serialized Dictionary Information) 파일에 저장한다.

## InnoDB 스토리지 엔진 아키텍처

- InnoDB 개략적 구조

<img alt="InnoDB 구조" src="/assets/img/posts/group/realmysql/2023-09-21-(6).png" style="width: 100%">

- InnoDB는 다른 스토리지 엔진과 달리 레코드 기반의 잠금을 제공한다.
    - 높은 **동시성 처리**가 가능하고, **안정적**이며 **성능**이 뛰어나다.

### 프라이머리 키에 의한 클러스터링

- InnoDB의 모든 테이블은 프라이머리 키 값의 순서대로 디스크에 저장된다.
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용한다.
- 옵티마이저에서 쿼리 실행을 계획할 때, 프라이머리 키는 다른 보조 인덱스에 비해 비중이 높다.

> 💡 MyISAM 스토리지 엔진은 클러스터링 키를 지원하지 않는다.
> - 프라이머리 키는 유니크 제약을 갖는 세컨더리 인덱스일 뿐이다.
> - 모든 인덱스는 물리적인 레코드의 주소 값(ROWID)을 갖는다.

### 외래 키 지원

- 외래 키에 대한 지원은 InnoDB 스토리지 엔진 레벨에서 지원하는 기능이다.
- 변경에 있어 부모 테이블과 자식 테이블 모두 데이터 확인 필요하다.
    - 잠금이 여러 테이블로 전파되고, 이로 인해 데드락이 발생할 수 있어 주의해서 사용해야 한다.
- `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면, 외래 키 관계에 대한 확인 작업을 일시정지 할 수 있다.
    - CASCADE 옵션도 무시된다.
    - 외래 키 기능을 다시 활성화 하기 전에는 반드시 부모 테이블과 자식 테이블의 일관성을 유지해야 한다.

### MVCC(Multi Version Concurrency Control)

- 레코드 레벨의 트랙잭션을 지원하는 DBMS가 제공하는 기능이다.
- 잠금을 사용하지 않는 **일관된 읽기**를 제공하기 위해 사용한다.
- InnoDB는 언두 로그(Undo log)를 이용해 해당 기능을 구현한다.
- InnoDB는 ACID(atomicity, consistency, isolation, durability)를 보장한다.
    - `UPDATE` 쿼리 실행
        - 언두 로그에 변경 전 값을 저장한다.
        - InnoDB의 버퍼 풀은 변경된 데이터로 갱신된다.
        - `COMMIT` 전에도 버퍼풀과 디스크의 데이터 파일은 대부분 동일하다.
    - `COMMIT`이나 `ROLLBACK` 전에 `SELECT` 쿼리 실행
        -  격리 수준(Isolation level)에 따라 다른 결과를 반환한다.
            - `READ_COMMITED`인 경우 InnoDB 버퍼 풀이 가지고 있는 변경된 데이터를 반환한다.
            - 그 이상의 격리 수준이(`REPEATABLE_READ`, `SERIALIZABLE`)인 경우 언두 로그에 보관된 변경되기 이전의 데이터를 반환한다.
    - `COMMIT` 또는 `ROLLBACK` 명령을 실행
        - `COMMIT` 명령 실행: InnoDB는 지금의 상태를 영구적인 데이터로 만든다.
            - 언두 영역의 내용은 커밋 명령 후 바로 삭제되지 않고, 해당 데이터를 참조하는 트랜잭션이 없을 때 삭제된다.
        - `ROLLBACK` 명령 실행: 언두 영역에 있는 데이터를 InnoDB 버퍼 풀로 다시 복구하고, 언두 영역의 내용을 삭제한다.
- 동시에 여러 버전을 관리하고, 필요에 따라 다른 데이터를 반환하는 구조를 **MVCC**라고 한다.

### 잠금 없는 일관된 읽기(Non-Locking Consistent Read)

- InnoDB 스토리지 엔진은 MVCC 기술을 통해 잠금을 걸지 않고 읽기 작업을 수행한다.
- 격리 수준이 `SERIALIZABLE`이 아닌 경우 `INSERT`와 연결되지 않는 순수한 읽기 작업은 다른 트랜잭션의 변경 작업과 관계 없이 바로 실행된다.
- 일관된 읽기를 위해 언두 로그를 삭제하지 못하고 계속 유지하기 때문에 MySQL 서버가 느려지는 문제가 발생할 수 있다.
    - 따라서 가능한 빨리 트랜잭션을 완료하는 것이 좋다.

### 자동 데드락 감지

- InnoDB 스토리지 엔진은 잠금 대기 목록을 그래프(Wait-for List) 형태로 관리하여 교착 상태를 체크한다.
- 데드락 감지 스레드가 주기적으로 그래프를 검사해 교착 상태에 빠진 트랜잭션들을 찾아 그 중 하나를 강제 종료한다.
    - 언두 로그 양이 적은 트랜잭션은 롤백으로 인한 MySQL 서버의 부하도 적기 때문에 강제 종료 대상이 된다.
- InnoDB 스토리지 엔진은 상위 레이어인 MySQL 엔진에서 관리되는 테이블 잠금은 확인 할 수 없다.
    - `innodb_table_locks` 시스템 변수를 통해 테이블 레벨의 잠금까지 감지할 수 있다.
    - 특별한 이유가 없다면 활성화 해야한다.
- 동시 처리 스레드가 많아지거나 트랜잭션이 가진 잠금의 수가 많아지면 데드락 감지 스레드가 느려지고, 서비스에 악영향을 미치게 된다.
    - MySQL 서버는 데드락 감지 스레드의 작동을 `innodb_deadlock_detect` 시스템 변수를 통해 제어할 수 있다.
    - 데드락 감지 스레드의 작동을 비활성화 할 경우 데드락 상태에 빠질 수 있다.
    - 이때를 위해, `innodb_lock_wait_timeout` 시스템 변수를 활성화 하면 데드락 상태에서 일상 시간이 지나면 요청이 실패처리 되고, 에러 메시지를 반환한다.
    - 따라서, 데드락 감지 스레드의 작동을 비활성화 할 경우 반드시 `innodb_lock_wait_timeout` 시스템 변수를 함께 설정해야 하며, 케이스에 따라 성능이 향상될 수 있다.

### 자동화된 장애 복구

- InnoDB는 손실이나 장애로부터 데이터를 보호하기 위해 MySQL 서버가 시작될 때 자동 복구를 수행한다.
    - 복구할 수 없는 손상이라면 자동 복구를 멈추고 MySQL 서버는 종료 된다.
    - 이때는 `innodb_force_recovery` 시스템 변수 설정을 통해 MySQL 서버를 시작해야 한다.
    - `innodb_force_recovery` 단계 별 복구 상황
        - 1(SRV_FORCE_IGNORE_CORRUPT)
            - 손상된 부분이 발견돼도 무시하고 MySQL 서버를 시작한다.
        - 2(SRV_FROCE_NO_BACKGROUND)
            - InnoDB는 쿼리 처리를 위해 여러 종류의 백그라운드 스레드를 동시에 이용하는데, 메인 스레드를 시작하지 않고 MySQL 서버를 시작한다.
        - 3(SRV_FORCE_NO_TRX_UNDO)
            - 일반적으로 MySQL 서버가 다시 시작될 때 언두 영역의 데이터를 데이터 파일에 적용하고, 리두 로그의 내용을 다시 덮어 써서 장애 시점의 데이터 상태를 만들어 낸다.
            - 하지만 3으로 설정하면 커밋되지 않고 종료된 트랜잭션은 계속 그 상태로 남아 있게 MySQL 서버를 시작한다.
        - 4(SRV_FROCE_NO_IBUF_MERGE)
            - InnoDB는 데이터 변경 작업을 상황에 따라 버퍼에 저장해두고 나중에 처리할 수 있다.
            - 이런 인서트 버퍼에 기록된 내용은 언제 데이터 파일에 병합(Merge)될지 알 수 없다.
            - MySQL이 재시작 될 때, 인서트 버퍼의 손상을 감지하면 InnoDB는 에러를 발생시키고 MySQL 서버는 시작하지 못한다.
            - 하지만 4로 설정하면 InnoDB 스토리 엔진이 인서트 버퍼의 내용을 무시하고 강제로 MySQL을 시작한다.
        - 5(SRV_FORCE_NO_UNDO_LOG_SCAN)
            - MySQL 서버는 종료 시점에 진행 중인 트랜잭션이 있다면, 커넥션을 강제로 끊고 별도의 작업 없이 종료한다.
            - MySQL이 다시 시작하면 InnoDB 엔진은 언두 레코드를 통해 페이지를 복구하고, 리두 로그를 적용해 종료 시점의 상태를 재현한다.
            - 그리고 마지막으로 커밋되지 않은 트랜잭션을 롤백 처리한다.
            - 하지만 5로 설정하면 InnoDB 엔지은 언두 로그를 모두 무시하고 MySQL을 시작한다.
        - 6(SRV_FORCE_NO_LOG_REDO)
            - InnoDB 스토리지 엔진의 리두 로그가 손상되면 MySQL 서버를 시작할 수 없다.
            - 6으로 설정하면 리두 로그를 모두 무시하고, 마지막 체크포인트 시점의 데이터만 남은채로 MySQL 서버를 시작한다.
- 수동 복구 모드로 서버가 가동되고, InnoDB 테이블이 인식된다면 mysqldump를 통해 데이터를 백업하고, 서버의 DB와 테이블을 다시 생성하는 것이 좋다.
- 마지막 풀 백업 시점부터 장애 시점까지의 바이너리 로그가 있다면 InnoDB 복구보다 풀 백업과 바이너리 로그로 복구하는 편이 데이터 손실이 적을 수 있다. 

### InnoDB 버퍼 풀

- InnoDB 스토리지 엔진에서 가장 핵심적인 부분이다.
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간으로, 쓰기 작업을 지연시켜 일괄 작업으로 처리할 수 있게 해주는 버퍼 역할도 한다.

#### 버퍼 풀의 크기 설정

- 운영체제와 각 클라이언트 스레드가 사용할 메모리를 고려해서 설정해야 한다.
- 레코드 버퍼가 메모리를 사용하는 특별한 경우를 제외하고, MySQL 서버 내에서 메모리를 필요로 하는 부분은 크게 없다.

> 💡 레코드 버퍼
> - 테이블의 레코드를 읽고 쓸 때 버퍼로 사용하는 공간
> - 버퍼 공간은 별도로 설정할 수 없고, 전체 커넥션 수와 각 커넥션이 사용하는 테이블 수에 따라 결정된다.

- MySQL 5.7 버전부터 `innodb_buffer_pool_size` 시스템 변수를 통해 InnoDB 버퍼 풀의 크기를 동적으로 조절할 수 있다.
    - 가능한 InnoDB 버퍼 풀의 크기는 작은 값으로 설정해서 상황에 따라 증가시키는 방법이 최적이다.
        - MysQL 서버를 이미 사용하고 있다면, 해당 서버의 메모리 설정을 기준으로 InnoDB 버퍼 풀의 크기를 조정하면 된다.
        - 최초 설정
            - 운영체제 메모리 8GB 미만: 50% 정도만 InnoDB 버퍼 풀로 설정하고 나머지는 MySQL 서버와 운영체제, 다른 프로그램이 사용할 수 있는 공간으로 확보하는 것이 좋다.
            - 운영체제 메모리 8GB 이상: InnoDB 버퍼 풀의 크기를 전체 메모리의 50%에서 시작해서 조금씩 올려가며 최적점을 찾는다.
            - 운영체제 메모리 50GB 이상: 15~30GB 정도를 운영체제와 다른 프로그램을 위해 남겨두고 나머지를 InnoDB 버퍼 풀로 설정한다.
- 버퍼 풀의 크기를 줄이는 작업은 크리티컬한 변경이다.
    - 버퍼 풀의 크기를 줄이는 작업은 하지 안거나, 서버가 여유 있는 시점에 진행해야 한다.
- InnoDB 버퍼 풀은 전통적으로 버퍼 풀 전체를 관리하는 세마포어로 인해 내부 잠금 경합을 유발해 왔지만, 버퍼 풀을 여러 개로 나눠 관리할 수 있도록 개선되었다.
    - 나눠진 각각의 버퍼 풀을 `버퍼 풀 인스턴스` 라고 하며, 8개로 초기화 된다.
        - 메모리 1GB 미만: 버퍼풀 인스턴스 1개만 생성
        - 버퍼 풀로 항당할 수 있는 메모리 40GB 이하: 기본 값 유지
        - 40GB 이상: 버퍼 풀 인스턴스당 5GB 정도 되도록 인스턴스 개수 설정

#### 버퍼 풀의 구조

- InnoDB 스토리지 엔진은 버퍼 풀이라는 메모리 공간을 페이지 크기로 나눠 데이터를 필요로 할 때마다 해당 데이터 페이지를 읽어서 저장한다.
    - 페이지 크기는 `innodb_page_size` 시스템 변수를 통해 설정할 수 있다.
- 페이지 크기로 나눠진 버퍼 풀을 관리하기 위해 InnoDB 스토리지 엔진은 크게LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 프리(Free) 리스트 3개의 자료구조를 관리한다.
    - 프리 리스트
        - InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
        - 새로 디스크의 데이터 페이지를 읽어와야 하는 경우 사용된다.
    - LRU 리스트
        - LRU와 MRU(Most Recently Used) 리스트가 결합된 형태

        <img alt="버퍼 풀 관리를 위한 LRU 리스트 구조" src="/assets/img/posts/group/realmysql/2023-09-21-(7).png" style="width: 100%">

        - LRU - `Old 서브리스트` 영역 / MRU - `New 서브리스트` 영역
        - LRU 리스트의 목적은 한 번 읽은 페이지를 오랫동안 버퍼 풀의 메모리에 유지함으로써, 디스크 접근은 최소화 할 수 있다.
        - InnoDB 스토리지 엔진의 데이터 찾는 과정
            1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는 검사
                1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지 검색
                2. 해당 테이블의 인덱스(B-Tree)를 이용해 버퍼 풀에서 페이지 검색
                3. 버퍼 풀에 데이터 페이지가 있다면, 해당 페이지의 포인터를 MRU 방향으로 승급
            2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
            3. 버퍼 풀의 LRU 헤더 부분에 적대된 데이터 페이가 실제로 읽히면 MRU 헤더 부분으로 이동
                - 대량 읽기의 경우 디스크의 데이터가 버퍼 풀에 적재는 되지만 쿼리에서 사용되지 않을 수도 있으며, 이런 경우 MRU로 이동되지 않는다.
            4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이(Age)가 부여된다.
                - 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 버퍼 풀에서 제거되고, 해당 작업을 Eviction이라고 한다.
                - 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화 된다.
            5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가한다.
        - 버퍼 풀 내부에서 데이터 페이지는 서로 경쟁을 통해 MRU 또는 LRU로 이동하고, LRU의 끝으로 밀려난 데이터 페이지를 버퍼 풀에서 제거하여 새로운 데이터 페이지를 적재할 수 있는 공간을 확보한다.
    - 플러시 리스트
        - 데이터가 변경된 상태에서 더티 페이지의 변경 시점 기준의 페이지 목록을 관리한다.

        > 💡 더티 페이지
        > - `INSERT`, `UPDATE`, `DELETE` 명령으로 변경된 데이터를 가진 페이지
        > - 디스크에 동기화 되지 않은 데이터를 가진 페이지

        - 데이터가 변경되면 InnoDB는 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영한다.
        - 리두 로그가 디스크로 기록됐다고 해서 데이터 페이지가 디스크로 기록됐다는 것을 보장하지 않는다.
            - InnoDB 스토리지 엔진은 체크포인트를 발생시켜 디스크의 리두 로그와 데이터 페이지의 상태를 동기화하게 된다.
            - 체크포인트는 MySQL 서버가 시작될 때 InnoDB 스토리지 엔진이 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점을 만드는 역할을 한다.

#### 버퍼 풀과 리두 로그

- InnoDB의 버퍼 풀과 리두 로그는 밀접한 관계를 맺고 있다.
- 버퍼 풀은 서버 메모리가 허용하는 만큼 크게 설정할수록 쿼리 성능이 빨라진다.
- InnoDB 버퍼 풀은 데이터베이스 서버의 성능 향상을 위해 데이터 캐시, 쓰기 버퍼링 두 가지 용도가 있다.
    - 버퍼 풀의 메모리 공간만 늘리는 것은 **데이터 캐시**의 기능만 향상시킨다.
    - 쓰기 버퍼링 기능까지 향상시키기 위해서는 InnoDB 버퍼 풀과 리두 로그의 관계를 먼저 이해해야 한다.
- InnoDB 버퍼 풀은 클리 페이지(Clean Page)와 더티 페이지(Dirty Page)를 가지고 있다.

> 💡 클리 페이지
>- 디스크에서 읽은 상태로 전혀 변경되지 않은 데이터를 가진 페이지

- InnoDB 스토리지 엔진에서 리두 로그는 1개 이상의 고정 크기 파일은 연결해서 순환 고리처럼 사용한다.
    - 데이터 변경이 계속 발생하면 리두 로그 파일에 기록됐던 로그 엔트리는 어느 순간 새로운 로그 엔트리로 덮어 쓰여진다.
        - 기록될 때마다 로그 포지션은 증가 되는데, 이를 LSN(Log Sequence Number)이라고 한다.
    - 따라서, InnoDB 스토리지 엔진은 리두 로그 파일에서 재사용 가능한 공간과 당장 재사용 불가능한 공간을 구분해서 관리한다.
        - 재사용 불가능한 공간을 활성 리두 로그(Active Redo Log)라고 한다.
- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화한다.
    - 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 된다.
    - 가장 최근 체크포인트의 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 체크포인트 에이지(Checkpoint Age)라고 한다.
        - 체크포인트 에이지는 활성 리두 공간의 크기와 동일하다.

#### 버퍼 풀 플러시(Buffer Pool Flush)

- MySQL 5.6 버전까지는 InnoDB 스토리지 더티 페이지 플러시 기능이 부드럽게 처리되지 않았다.
    - 데이터 페이지가 많으면 디스크 기록이 폭증해서 MySQL 서버의 사용자 쿼리 처리 성능에 영향을 미쳤다.
- MySQL 8.0 버전 부터는 2개의 플러시 기능을 백그라운드로 실행하여 더티 페이지의 디스크 쓰기 동기화 관련 폭증 현상이 더 이상 발생하지 않는다.
    - 서비스 운영할 때, 성능 문제가 발생하지 않는다면 굳이 시스템 변수들을 조정할 필요는 없다.

1. 플러시 리스트(Flush_list) 플러시
   - 플러시 리스트에서 오래전에 변경된 데이터 페이지 순서대로 디스크에 동기화하는 작업
       - 오래된 리두 로그 엔트리가 사용하는 공간을 비워두기 위해서 InnoDB 버퍼 풀의 더티 페이지가 디스크에 동기화돼야 한다.
   - InnoDB 스토리지 엔진에서 더티 페이지를 디스크로 동기화하는 스레드를 **클리너 스레드(Cleaner Thread)**라고 한다.
       - `innodb_page_cleaners` 시스템 변수를 통해 클리너 스레드 개수를 조정할 수 있다.
       - 가능하면 `innodb_page_cleaners` 설정값은 `innodb_buffer_pool_instances` 설정값과 동일하게 설정하는 것을 권장한다.
   - 기본적으로 InnoDB 스토리지 엔진은 전체 버퍼 풀이 가진 페이지의 90%까지 더티 페이지를 가질 수 있다.
       - 일반적으로 InnoDB 버퍼 풀은 더티 페이지를 많이 가지고 있을수록 버퍼링은 통한 디스크 쓰기를 줄이는 효과를 극대화할 수 있다.  
       - `innodb_max_dirty_pages_pct` 시스템 변수를 통해 더티 페이지의 비율을 조정할 수 있으며, 기본값을 유지하는 것이 좋다.
   - 하지만 InnoDB 버퍼 풀에 더티 페이지가 많을수록 디스크 쓰기 폭발(Disk IO Burst) 현상이 발생할 가능성이 높다.
       - 더티 페이지의 비율이 90%가 넘어가면 InnoDB 스토리지 엔진은 급작스럽게 디스크 쓰기가 폭증하는 현상이 발생한다.
       - 이런 문제를 완화하기 위해 InnoDB 스토리지 엔진에서는 `innodb_max_dirty_pages_lwm` 시스템 변수를 통해 일정 수준 이상 더티 페이지가 발생하면 점진적으로 디스크로 기록하고 있다.
   - **어댑티브 플러시(Adaptive flush)** 기능은 리두 로그의 증가 속도를 분석하여 적절한 더티 페이지 수준을 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 조절한다.
       - 리두 로그 공간이 `innodb_adaptive_flushing_lwm` 시스템 변수 설정값을 초과하면 어댑티브 플러시 알고리즘이 활성화 된다.
2. LRU 리스트(LUR_list) 플러시
   - 사용 빈도가 낮은 데이터 페이지들을 제거해서 새로운 페이지들을 읽어올 공간을 만드는 작업
   - InnoDB 스토리지 엔진은 LRU 리스트의 끝부분부터 시작해서 최대 `innodb_lru_scan_depth` 시스템 변수 설정값 만큼 페이지들을 스캔한다.
   - 클린 페이지는 즉시 프리(Free) 리스트로 페이지를 옮긴다.

#### 버퍼 풀 상태 백업 및 복구

- InnoDB 서버의 버퍼 풀은 쿼리의 성능과 밀접하게 연결돼 있다.
- 디스크의 데이터를 버퍼 풀에 적재된 상태를 워밍업(Warming Up) 상태라고 한다.
    - 버퍼 풀이 워밍업 되지 않은 상태에서는 몇십 배 낮은 쿼리 처리 속도를 보여준다.
- MySQL 5.5 버전에서는 서비스 오픈 전 강제로 주요 테이블과 인덱스에 대해 풀 스캔 하는 방식으로 워밍업 상태로 만들었다.
- MySQL 5.6 버전부터는 버퍼 풀 덤프 및 적재 기능이 도입됐다.
    - InnoDB 버퍼 풀 상태 백업
        ```sql
        SET GLOBAL innodb_buffer_pool_dump_now=ON;
        ```
        - InnoDB 버퍼 풀 백업은 LRU 리스트에 적재된 데이터 페이지의 메타 정보만 가져와서 저장하기 때문에 빠르게 완료된다.
    - InnoDB 버퍼 풀 상태 복구
        ```sql
        SET GLOBAL innodb_buffer_pool_load_now=ON;
        ```
        - InnoDB 버퍼 풀 복구는 각 테이블의 데이터 페이지를 다시 디스크에서 읽어와야 하기 때문에 InnoDB 버퍼 풀의 크기에 따라 상당한 시간이 걸릴 수 있다.
    - 버퍼 풀 백업과 복구를 자동화하려면 `innodb_buffer_pool_dump_at_shutdown`와 `innodb_buffer_pool_load_at_startup` 설정을 MySQL 서버 설정 파일에 넣어두면 된다.

#### 버퍼 풀의 적재 내용 확인

- MySQL 5.6 버전부터 서버의 `information_schema` 데이터베이스 `innodb_buffer_page` 테이블을 통해 InnoDB 버퍼 풀의 메모리를 확인할 수 있다.
    - InnoDB 버퍼 풀이 큰 경우 테이블 조회가 큰 부하를 일으켜, 서비스용으로 사용되는 MySQL 서버에서는 버퍼 풀의 상태를 확인하는 것이 불가능 했다.
- MySQL 8.0 버전에서는 문제점 개선을 위해 `information_schema` 데이터베이스에 `inndb_cached_indexes` 테이블이 추가됐다.
    -  `inndb_cached_indexes` 테이블을 이용하면 인덱스별로 데이터 페이지가 얼마나 InnoDB 버퍼 풀에 적재돼 있는지 확인할 수 있다.

https://xonmin.tistory.com/63?category=1077527
https://neverfadeaway.tistory.com/61
